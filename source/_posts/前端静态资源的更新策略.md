---
title: 前端静态资源的更新策略
date: 2020-03-09 17:05:56
categories:
  - webpack
tags: 
  - webpack
  - 前端工程化
---

## 前言

上一篇【[HTTP缓存策略](https://hpcplus2.github.io/2019/07/04/HTTP%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/)】文章中，我们了解了如何通过`HTTP缓存机制`以减少网络请求来提升页面新能。但是如果在资源的有效期内，项目进行了迭代，为了保证用户第一时间获取到最新资源，就必须让浏览器放弃使用之前的缓存资源，使用最新的资源。

通过上述的需求，引出今天我们要讲的内容，前端静态资源的更新策略：`覆盖更新`和`增量更新`。

## 覆盖更新

覆盖更新顾名思义，直接用新的文件去覆盖掉部署服务器上的文件。但是由于缓存机制的原因，用户在访问页面的时候会直接读取缓存中的资源，否则需要等到缓存失效或者用户强制刷新，这肯定不是我们想要看到的结果。

基于上述的问题，覆盖更新的做法是通过给静态资源的URL添加请求参数，一般是版本号或者hash值，如`index.scss` => `index.scss?v=0.11.2`或者`index.scss` => `index.scss?hash=e12335`。

如果前端静态资源部署是在同一台服务器上的，一般没有问题。但是，现在的部署方式基本上是将index.html入口文件部署在服务器，而将其余静态资源(如js，css，图片)部署在CDN上面，这里就会存在到底应该先部署谁的问题。

* 如果我们先部署入口文件，则用户可能访问到的还是旧的静态资源
* 如果我们先部署静态资源，则cdn上旧的静态资源会被我们直接覆盖掉，如果用户的入口文件未更新成最新的，则可能导致页面问题
* 由于覆盖更新会直接覆盖掉旧的静态资源，如果想要实现版本回滚，就需要额外保存旧资源文件

通过增量更新，我们可以有效解决当前部署方式使用覆盖更新导致的这些问题。

## 增量更新

增量更新的做法就是，将文件的hash值，直接作为文件名称的一部分，而不像覆盖更新那样，添加在URL的请求参数里面。例如，打包后的文件名称`index.scss` => `index.e123r`。这样新的静态资源不会覆盖掉旧的静态资源，这样就实现了`增量更新`。

增量更新的部署顺序是先部署静态资源，由于新的静态资源没有入口文件，提前上线不会造成线上问题。当静态资源部署成功之后，再部署入口文件。这样用户可以在入口文件部署成功之后第一时间访问到最新的静态资源。

增量更新的版本回滚相较覆盖更新也简单很多，因为迭代版本的静态资源全部存储在部署服务器上，所以仅需要回滚一下入口文件即可。

## 通过webpack实现增量更新

上面提到了，增量更新是通过给静态资源文件名称插入hash值来实现的。这里简要介绍一下如何通过webpack的配置来实现文件名称自动添加hash。

#### js输出配置

```
output: {
    path: globals.DistDirectory,
    filename: '[name]-[chunkhash:16].js',
    chunkFilename: '[name]-[chunkhash:16].js',
    publicPath: ''
}
```

#### css输出配置

```
new MiniCssExtractPlugin({
		filename: '[name]-[contenthash:16].css',
		chunkFilename: '[name]-[contenthash:16].css',
})
```

注：以上配置基于webpack4

通过上述配置项我们可以看出，我们是通过配置filename或者chunkFilename将`hash`插入到文件名中，来生成新的文件。

这边延伸出两个问题:

* 不同的`hash`类型的意义
* 每次编译都需要增量更新吗？是否可以只更新修改的文件?

### 不同的hash类型

#### hash

> webpack中对于hash的定义：The hash of the compilation

webpack中的compilation对象代表某个版本的资源对应的编译进程。当使用webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。compilation对象不是针对单个文件的，而是针对项目中所有参与构建的文件的。换句话说，只要任何一个文件内容有改动，compilation对象便会改变，作为compilation的hash值也就相应的发生改变。

简单的来说，如果使用`hash`作为构建输出文件名称的配置，任意一个文件的改动都会影响所有资源的缓存。

#### chunkhash

> chunkhash表示"块"自身的代码内容计算所得的hash值。

`chunk`在webpack中的含义可以简单的理解为散列模块经合并后的"块"，这边涉及到同步模块和异步模块的概念，后续会专门补充一篇关于`webpack与按需加载`的文章，这边我们知道他们是不同的"块"即可。

#### contenthash

> contenthash表示被导出内容计算所得的hash值。

`contenthash`不是webpack自身的功能，而是由`MiniCssExtractPlugin`(v4之前版本使用`ExtractTextPlugin`)提供的功能，仅针对css内容。

一个前提，webpack中所有的类型都必须借助js文件参与构建，比如css源文件必须在js中引入。所以webpack默认将构建后的css代码合并到引用他的js文件中，然后在该js运行时，动态添加<style>标签。当然实际项目中，我们往往是将css文件单独抽离出来，这样既有利于浏览器的渲染优化，又能够更好的利用客户端缓存。这就需要借助`MiniCssExtractPlugin`。

在指定构建文件名称时，将hash指定为`contenthash`是解耦js和css文件的关键。如果css文件使用`hash`或者`chunkhash`，则js文件或者css文件任一文件发生修改，都会使对方的hash值改变，近而影响到缓存，这肯定不是我们想要的，我们的需求是js和css的代码改动仅影响他们自身。当通过`MiniCssExtractPlugin`指定`contenthash`后，只有css文件发生变更时才会改变自己的hash值，同时并不会对js文件的hash产生影响。

#### TODO 待补充每种hash类型不同文件修改后对构建文件产生影响的Lis

| 类型 | 变化时机 |
| --- | ---- |
| hash | 任意文件变动 |
| chunkhash | chunk包含的文件变动 |
| contenthash | css文件发生变动 |

## 总结

通过本篇文章，我们应该对前端工程的更新策略有了一定的理解，同时清楚不同的hash类型对于更新策略的影响。每个项目的部署方案，缓存策略可能都不一样。我们可以结合自身需求，选择相应的更新策略。


> 文章参考资料
>
> [《前端工程化体系设计与实践》](https://e.jd.com/30391007.html)