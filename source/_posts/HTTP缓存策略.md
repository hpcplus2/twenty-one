---
title: HTTP缓存策略
date: 2019-07-04 22:16:41
categories:
  - HTTP
tags: 
  - HTTP
  - 性能优化
---


## 前言

很多时候我们碰到页面资源未更新问题，都知道这是缓存造成的，一般情况下我们都是通过清理缓存来解决问题。但是你了解资源哪些情况下会进行缓存，又是什么情况下缓存会过期？此文希望探究一下缓存策略的相关细节，让我们对缓存策略有一个较为全面的了解。

## HTTP缓存策略有哪些

### 强制缓存

强制缓存根据过期时间决定使用本地缓存还是请求新资源

强制缓存根据HTTP头部中的`Cache-Control`和`Expires`来判断

#### Cache-Control

`Cache-Control`可以由多个字段组合而成，这里主要介绍以下几种

* `no-cache` **不是字面意思上的不缓存**，而是要求所有缓存了该资源的用户，在使用缓存资源之前，发送带验证的请求到服务器确认资源是否发生变化
* `no-store` 真正意义上的禁止缓存，每次请求都要向服务器重新获取数据
* `max-age` 指定从请求的时刻开始计算，此次响应的缓存有效的最长时间（单位是秒）
* `public` 表明响应可以被任何对象（发送请求的客户端、cdn等等）缓存
* `private` 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存（cdn等）

#### Expires

指定一个明确的时间点作为缓存资源的过期时间，在此时间点之前客户端将使用本地缓存，而不会向服务器发送请求。`Expires`有一个很大的缺点，所指定的时间点是服务器时间，但是客户端进行判断的时候，是将其和本地时间作对比，当两者出现误差时，缓存就会失效。

和此策略类似的就是`Cache-Control`中的`max-age`，他指定的是缓存的时间跨度，而非某个时间点，不会受客户端与服务器时间误差的影响。所以，相比于`Expires`，`max-age`更精确。同时**在缓存策略里面，`max-age`的优先级比`Expires`更高**。

<!-- more -->

### 协商缓存

缓存的时间到期了，不一定意味着资源内容发生了变化，如果请求的资源和本地的缓存没有区别，实际上不需要再次请求，这时候就需要通过某些机制去判断服务器资源是否发生变更，这就是协商缓存。

协商缓存是通过HTTP头部的`Last-Modified/If-Modified-Since`、`Etag/If-None-Match`字段取判断是否资源发生变更

#### Last-Modified/If-Modified-Since

 `Last-Modified`指服务器端资源的**最后修改时间**，响应头部会带上这个标识。第一次请求之后，浏览器记录这个时间。
 
 再次请求时，请求头部带上`If-Modified-Since`即为之前记录下的时间。服务器端收到带 `If-Modified-Since`的请求后会去和资源的最后修改时间对比。若修改过就返回最新资源，状态码`200`，若没有修改过则返回`304`

#### Etag/If-None-Match

`Etag`是服务器为资源分配的一种唯一标识，作为响应头部信息返回给客户端。浏览器在`Cache-Control`指定了`no-cache`或者`max-age`和`Expires`均过期之后，会将`Etag`的值通过`If-None-Match`作为请求头部信息发送给服务器。

服务器接受到请求之后，通过对比请求头部中的`Etag`值是否改变，若修改过就返回最新资源，状态码`200`，若没有修改过则返回`304`

#### 关于 last-modified 和 Etag 区别

* 某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新
* `Last-modified`只能精确到秒
* 一些资源的最后修改时间改变了，但是内容没改变，使用`Last-modified`判断不了内容是否改变
* `Etag`的精度比`Last-modified`高，属于强验证，要求资源字节级别的一致，优先级高。如果服务器端有提供`Etag`的话，必须先对`Etag`进行 `Conditional Request`

#### 注意

计算`Etag`是需要占用资源的，如果修改不是过于频繁，看自己的需求用 `Cache-Control`是否可以满足


## HTTP缓存策略流程图

![](https://raw.githubusercontent.com/hpcplus2/resource/master/HTTP缓存策略.png)

## 总结

通过以上说明，我们对缓存策略的流程有了一个简单的了解。实际应用场景上，我们还需要根据业务需求来决定使用哪种缓存方式。以上！


> 文章内容参考资料:
> 
> [HTTP 缓存控制](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)
> 
> [HTTP 缓存机制一二三](https://zhuanlan.zhihu.com/p/29750583)